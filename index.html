<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>fast</title>
  <style>
    body {
      margin: 0;
      cursor: none;
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>
  <script id="fragmentShaderSource" type="x-shader/x-fragment">
    precision highp float;

    uniform vec2 uWindowResolution;
    uniform vec2 uImageResolution;
    uniform sampler2D uImage;
    
    float hash12(vec2 p) {
      vec3 p3 = fract(vec3(p.xyx) * .1031);
      p3 += dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }

    void main() {
      vec3 color = vec3(0.0);
      
      // screen curvature
      vec2 uv = (gl_FragCoord.xy / uWindowResolution * 2.0 - 1.0);
      uv.x *= 1.0 + pow(abs(uv.y) / 4.0, 2.0);
      uv.y *= 1.0 + pow(abs(uv.x) / 4.0, 2.0);
      uv = (uv + 1.0) / 2.0;
      uv.y = 1.0 - uv.y;
    
      if (uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0) {
        // image color with some chromatic abberation
        vec2 redOffset = vec2(0.002, 0.0);
        vec2 blueOffset = vec2(-0.002, 0.0);
        color.r = texture2D(uImage, uv + redOffset).r;
        color.g = texture2D(uImage, uv).g;
        color.b = texture2D(uImage, uv + blueOffset).b;
    
        // phosphor dot pattern
        vec2 dotUV = uv * uImageResolution;
        vec2 dotCoord = fract(dotUV) - 0.5;
        float dotSize = 0.4;
        float dot1 = smoothstep(dotSize, dotSize * 0.9, length(dotCoord));
        vec2 greenOffset = vec2(0.0, 0.33);
        float greenDot = smoothstep(dotSize, dotSize * 0.9, length(fract(dotUV + greenOffset) - 0.5));
        color = mix(color, color * vec3(dot1, greenDot, dot1), 0.5);
    
        // noise
        color += hash12(floor(uv * uImageResolution * 4.0)) * 0.03;
    
        // scanlines
        color -= sin(uv.y * uImageResolution.y * 4.0) * 0.01;
    
        // vignette
        color *= 1.0 - length((uv - 0.5) * 1.2);
    
        // saturation
        float saturation = 0.6;
        vec3 gray = vec3(dot(color, vec3(0.299, 0.587, 0.114)));
        color = mix(gray, color, saturation);
    
        // brightness boost
        color *= 1.1;
    
        // gamma correction
        color = pow(color, vec3(1.0 / 2.4));
    
        // color grading
        vec3 sepia = vec3(1.2, 1.0, 0.8);
        color = mix(color, color * sepia, 0.3);
      }
    
      gl_FragColor = vec4(color, 1.0);
    }
  </script>
  <script>
    function createShader(gl, type, source) {
      let shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
      let program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      return program;
    }

    function createTexture(gl, width, height) {
      let texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      let emptyData = new Uint8Array(width * height * 4);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, emptyData);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      return texture;
    }

    let imageWidth = 280;
    let imageHeight = 192;
    let windowWidth = imageWidth * 4;
    let windowHeight = imageHeight * 4;

    let canvas = document.querySelector("#canvas");
    canvas.width = windowWidth;
    canvas.height = windowHeight;
    let gl = canvas.getContext("webgl");
    let vertexShaderSource = "attribute vec4 aPosition;void main(){gl_Position=aPosition;}";
    let fragmentShaderSource = document.querySelector("#fragmentShaderSource").textContent;
    let vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    let fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    let program = createProgram(gl, vertexShader, fragmentShader);
    let positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    let positionLocation = gl.getAttribLocation(program, "aPosition");
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    let uWindowResolution = new Float32Array([windowWidth, windowHeight]);
    let uImageResolution = new Float32Array([imageWidth, imageHeight]);
    let uImage = createTexture(gl, imageWidth, imageHeight);
    let uImagePixelData = new Uint8Array(imageWidth * imageHeight * 4);
    let uImage2 = createTexture(gl, imageWidth, imageHeight);
    let uImagePixelData2 = new Uint8Array(imageWidth * imageHeight * 4);
    let useImage1 = true;

    let keys = {};
    document.onkeydown = e => keys[e.code] = true;
    document.onkeyup = e => delete keys[e.code];
    let mouse = {
      x: 0,
      y: 0
    };
    document.onmousemove = e => {
      mouse.x = Math.floor(e.clientX / windowWidth * imageWidth);
      mouse.y = Math.floor(e.clientY / windowHeight * imageHeight);
    }

    function render(useImage1 = true) {
      const pixelData = useImage1 ? uImagePixelData : uImagePixelData2;

      pixelData.fill(0);

      const squareSize = 10;
      const halfSize = Math.floor(squareSize / 2);

      for (let y = 0; y < imageHeight; y++) {
        for (let x = 0; x < imageWidth; x++) {
          if (x == mouse.x || y == mouse.y || (x >= mouse.x - halfSize && x <= mouse.x + halfSize && (y == mouse.y - halfSize || y == mouse.y + halfSize)) || (y >= mouse.y - halfSize && y <= mouse.y + halfSize && (x == mouse.x - halfSize || x == mouse.x + halfSize))) {
            pixelData[(x + y * imageWidth) * 4 + 0] = 255;
            pixelData[(x + y * imageWidth) * 4 + 1] = 255;
            pixelData[(x + y * imageWidth) * 4 + 2] = 255;
          }
        }
      }

      gl.bindTexture(gl.TEXTURE_2D, useImage1 ? uImage : uImage2);
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, imageWidth, imageHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
      let uImageToUse = useImage1 ? uImage : uImage2;
      useImage1 = !useImage1;
      let uWindowResolutionLocation = gl.getUniformLocation(program, "uWindowResolution");
      let uImageResolutionLocation = gl.getUniformLocation(program, "uImageResolution");
      let uImageLocation = gl.getUniformLocation(program, "uImage");
      gl.useProgram(program);
      gl.uniform2fv(uWindowResolutionLocation, uWindowResolution);
      gl.uniform2fv(uImageResolutionLocation, uImageResolution);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, uImageToUse);
      gl.uniform1i(uImageLocation, 0);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      requestAnimationFrame(render);
    }

    render();
  </script>
</body>

</html>